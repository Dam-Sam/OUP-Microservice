High-performance distributed system built in Java using microservices and containerized infrastructure. Capable of handling over 5900 requests/sec during demo testing â€” nearly 300x improvement over initial baseline. Designed for horizontal scalability, modularity, and fault-tolerant real-time load handling.

ğŸ¥ˆ Finished 2nd in throughput challenge â€” first place team implemented non-functional shortcuts to artificially inflate throughput
âœ… Achieved perfect score on project evaluation
ğŸ§  Refactored and optimized entire system beyond team baseline implementation

ğŸ”§ Tech Stack
Languages	Frameworks & Tools	Infrastructure
Java (Virtual Threads)	Hazelcast, Postgres, Docker, Bash	Nginx (load balancing), Linux (screen), Custom CLI
Shell scripting	Git	JVM 21+, Maven (dynamic jar handling)
ğŸŒ Architecture Overview
This project consists of four primary microservices:

UserService: CRUD operations for users
ProductService: Product catalog with stock management
OrderService: Order placement, tracking, and purchase history
Each service:

Operates independently with its own endpoint
Shares a centralized Postgres database with connection pooling
Utilizes both in-memory (local) and Hazelcast (distributed) caching
Exposes HTTP APIs used by a custom load generation and testing engine
A reverse proxy powered by Nginx distributes load across clusters for horizontal scaling.

ğŸš€ Performance & Optimization Highlights
Optimization	Impact
âš™ï¸ Java Virtual Threads	Reduced thread overhead, unlocked massive concurrency
ğŸ§  Caching Strategy (Hazelcast + Memory)	Cut latency by 150%
ğŸ’¾ DB Write Batching + Indexes	Improved throughput and reduced I/O load
ğŸŒ Nginx Load Balancing	Increased request parallelism and fault tolerance
ğŸ”„ Reusable HTTP Clients + Connection Pools	Eliminated recreate/destroy bottlenecks
ğŸ§¼ Logging Optimization	Boosted production performance via minimal I/O noise
ğŸ› ï¸ Codebase Refactor	SOLID principles applied, removed redundancy, introduced abstractions
ğŸ§ª Advanced Testing DSL	Enabled complex simulation and performance profiling
Final benchmark:
ğŸ”¥ ~5900 req/s at demo, ~10,000 req/s locally under distributed mode
ğŸ“‰ Initial baseline: 27 req/s

ğŸ’¡ Innovation: Custom Load Testing DSL
Created a domain-specific language (DSL) for realistic scenario simulation, supporting:

Loops, variables, conditionals
Randomized inputs
Parallel execution with sync control
Response assertions (HTTP code + body)
GOTO and flow control
Timers, sleep delays, and console tracing
ğŸ” DSL made it possible to test edge cases, performance regressions, and failure scenarios in ways the professor-provided suite could not.

ğŸ“ Example Test Script (Basic)
ğŸ“ Advanced Test Script (High Load)

ğŸ“¸ Demo Snapshot
ğŸ“ Demo performed on-campus using real-time test loads
ğŸ§ª Verified persistence, concurrent correctness, and error handling
ğŸ”— GitHub Repo

ğŸ§± How to Run Locally
ğŸ³ Prerequisites
Linux/macOS environment (or WSL)
Java 21+
Bash, screen, and docker installed
âš™ï¸ Compilation
./runme.sh -c
Downloads JDK 21, compiles code, and pulls dependencies automatically.

ğŸš€ Start All Services
./runme.sh -a
Each service runs in its own screen. Use:

./runme.sh -su   # switch to UserService
./runme.sh -p    # switch to ProductService
./runme.sh -o    # switch to OrderService
Detach from screen: Ctrl+A then D.

ğŸ”„ Stop All Services
./runme.sh -x
ğŸ§  Key Learnings
Deep understanding of distributed systems under high load
Leveraged performance profiling for bottleneck analysis and targeted tuning
Applied real-world software architecture patterns (scalability, resiliency, abstraction)
Built tooling (scripts, config systems, DSL) that streamlined dev/test ops
Learned the importance of writing good code, not just working code
ğŸ§‘â€ğŸ’» Contributions & Ownership
Although this was a team project, the initial codebase was largely non-functional.
I independently:

Refactored all core services
Designed the caching and load balancing strategy
Built the DSL testing engine and CLI scripts
Engineered the final system that far exceeded performance expectations
ğŸ§© Configuration System
Flexible JSON config supports:

Per-service overrides
Pool sizes, timeouts, queue lengths
Cache type/parameters
Logging verbosity
Host IP autodetection
Rapid switching between test environments
ğŸ“„ Example Config File

ğŸ“š Project Background
This was a capstone-style project for a university distributed systems course, with the goal of:

Scaling microservices to support 1000+ concurrent clients
Demonstrating resiliency and state consistency under high throughput
Showcasing design thinking and engineering rigor
ğŸ“„ [Assignment Details](include link or PDF if available)

ğŸ“ Links
ğŸ”— Live GitHub Repo
ğŸ“„ Advanced Test Script
ğŸ› ï¸ Startup Script
ğŸ“¢ Contact
ğŸ‘¤ Sam Zhang
ğŸ“¬ sam.zhangv1.0@gmail.com
ğŸ”— LinkedIn | GitHub
